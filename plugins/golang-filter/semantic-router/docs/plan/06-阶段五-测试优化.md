# é˜¶æ®µäº”: æµ‹è¯•ä¸ä¼˜åŒ–

## ç›®æ ‡

è¿›è¡Œå…¨é¢çš„ç³»ç»Ÿæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œç¡®ä¿æ»¡è¶³æ¯”èµ›è¯„åˆ†æ ‡å‡†ã€‚

**é¢„æœŸæˆæœ**:
- âœ… å®Œæ•´çš„åŠŸèƒ½æµ‹è¯•è¦†ç›–
- âœ… æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡ (å‡†ç¡®ç‡ > 85%, å»¶è¿Ÿ < 50ms)
- âœ… å‹åŠ›æµ‹è¯•é€šè¿‡
- âœ… å®Œæ•´çš„æ–‡æ¡£å’Œæ¼”ç¤º

**é¢„è®¡æ—¶é—´**: 4-5 å¤©

---

## ä»»åŠ¡æ¸…å•

### Task 5.1: åŠŸèƒ½æµ‹è¯•

**ç›®æ ‡**: éªŒè¯æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ­£å¸¸å·¥ä½œ

#### 5.1.1 å•å…ƒæµ‹è¯•

**åˆ†ç±»æœåŠ¡æµ‹è¯•** (`classifier-service/test_classifier.py`):
```python
import pytest
import grpc
import classifier_pb2
import classifier_pb2_grpc

@pytest.fixture
def classifier_stub():
    """åˆ›å»ºåˆ†ç±»æœåŠ¡å®¢æˆ·ç«¯"""
    channel = grpc.insecure_channel('localhost:50051')
    return classifier_pb2_grpc.ClassifierServiceStub(channel)

def test_classify_math(classifier_stub):
    """æµ‹è¯•æ•°å­¦é—®é¢˜åˆ†ç±»"""
    request = classifier_pb2.ClassifyRequest(
        text="æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0",
        enable_cache=False
    )
    response = classifier_stub.Classify(request)

    assert response.category == "math"
    assert response.confidence > 0.7
    assert response.latency_ms < 50

def test_classify_code(classifier_stub):
    """æµ‹è¯•ä»£ç é—®é¢˜åˆ†ç±»"""
    request = classifier_pb2.ClassifyRequest(
        text="å†™ä¸€ä¸ª Python å‡½æ•°å®ç°å¿«é€Ÿæ’åº",
        enable_cache=False
    )
    response = classifier_stub.Classify(request)

    assert response.category == "code"
    assert response.confidence > 0.7

def test_classify_medicine(classifier_stub):
    """æµ‹è¯•åŒ»å­¦é—®é¢˜åˆ†ç±»"""
    request = classifier_pb2.ClassifyRequest(
        text="å¤´ç—›çš„å¸¸è§åŸå› æœ‰å“ªäº›?",
        enable_cache=False
    )
    response = classifier_stub.Classify(request)

    assert response.category == "medicine"
    assert response.confidence > 0.7

def test_health_check(classifier_stub):
    """æµ‹è¯•å¥åº·æ£€æŸ¥"""
    request = classifier_pb2.HealthCheckRequest()
    response = classifier_stub.HealthCheck(request)

    assert response.healthy == True
    assert response.model_status == "loaded"

def test_cache_hit(classifier_stub):
    """æµ‹è¯•ç¼“å­˜å‘½ä¸­"""
    text = "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•é—®é¢˜"

    # ç¬¬ä¸€æ¬¡è°ƒç”¨
    request1 = classifier_pb2.ClassifyRequest(text=text, enable_cache=True)
    response1 = classifier_stub.Classify(request1)

    # ç¬¬äºŒæ¬¡è°ƒç”¨ (åº”è¯¥å‘½ä¸­ç¼“å­˜)
    request2 = classifier_pb2.ClassifyRequest(text=text, enable_cache=True)
    response2 = classifier_stub.Classify(request2)

    assert response1.category == response2.category
    assert response2.method == "cache"
    assert response2.latency_ms < response1.latency_ms

if __name__ == '__main__':
    pytest.main([__file__, '-v'])
```

**è¿è¡Œæµ‹è¯•**:
```bash
cd classifier-service
pytest test_classifier.py -v
```

#### 5.1.2 é›†æˆæµ‹è¯•

**è·¯ç”±åŠŸèƒ½æµ‹è¯•** (`test/integration/test_routing.sh`):
```bash
#!/bin/bash

set -e

GATEWAY_URL="http://localhost:8001"
RESULTS_FILE="./test_results.json"

echo "=========================================="
echo "Higress Semantic Router Integration Test"
echo "=========================================="

# æµ‹è¯•ç”¨ä¾‹
declare -a TEST_CASES=(
    "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0:math:qwen-math-7b"
    "å†™ä¸€ä¸ª Python å¿«é€Ÿæ’åºç®—æ³•:code:qwen-code-7b"
    "å¤´ç—›çš„å¸¸è§åŸå› æœ‰å“ªäº›:medicine:qwen-medicine-7b"
    "å¸®æˆ‘å†™ä¸€ç¯‡å…³äºç¯ä¿çš„æ–‡ç« :writing:qwen-writing-7b"
    "ä½ å¥½,ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·:general:qwen-max"
)

PASS_COUNT=0
FAIL_COUNT=0

for test_case in "${TEST_CASES[@]}"; do
    IFS=':' read -r question expected_category expected_model <<< "$test_case"

    echo ""
    echo "Testing: $question"
    echo "Expected category: $expected_category"
    echo "Expected model: $expected_model"

    # å‘é€è¯·æ±‚
    response=$(curl -s -X POST "$GATEWAY_URL/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -d "{
            \"messages\": [{\"role\": \"user\", \"content\": \"$question\"}]
        }" -v 2>&1)

    # æå–è·¯ç”±å¤´
    category=$(echo "$response" | grep -i "X-Classification:" | awk '{print $3}' | tr -d '\r')
    model=$(echo "$response" | grep -i "X-Target-Model:" | awk '{print $3}' | tr -d '\r')
    confidence=$(echo "$response" | grep -i "X-Confidence:" | awk '{print $3}' | tr -d '\r')

    # éªŒè¯ç»“æœ
    if [ "$category" = "$expected_category" ] && [ "$model" = "$expected_model" ]; then
        echo "âœ“ PASS - Category: $category, Model: $model, Confidence: $confidence"
        ((PASS_COUNT++))
    else
        echo "âœ— FAIL - Got category: $category, model: $model"
        ((FAIL_COUNT++))
    fi
done

echo ""
echo "=========================================="
echo "Test Summary"
echo "=========================================="
echo "Total: $((PASS_COUNT + FAIL_COUNT))"
echo "Passed: $PASS_COUNT"
echo "Failed: $FAIL_COUNT"

if [ $FAIL_COUNT -eq 0 ]; then
    echo "âœ“ All tests passed!"
    exit 0
else
    echo "âœ— Some tests failed"
    exit 1
fi
```

#### 5.1.3 æ•°æ®æ”¶é›†æµ‹è¯•

**æ•°æ®é£è½®æµ‹è¯•** (`test/integration/test_data_collection.py`):
```python
import requests
import json
import time

def test_training_mode():
    """æµ‹è¯•è®­ç»ƒæ¨¡å¼æ•°æ®æ”¶é›†"""

    # é…ç½®
    gateway_url = "http://localhost:8001"
    collector_url = "http://localhost:8080"

    # æµ‹è¯•é—®é¢˜
    questions = [
        "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0",
        "å†™ä¸€ä¸ª Python å¿«é€Ÿæ’åº",
        "å¤´ç—›æ€ä¹ˆåŠ"
    ]

    print("Testing training mode data collection...")

    # å‘é€æµ‹è¯•è¯·æ±‚
    for question in questions:
        response = requests.post(
            f"{gateway_url}/v1/chat/completions",
            json={
                "messages": [{"role": "user", "content": question}]
            }
        )
        assert response.status_code == 200
        print(f"âœ“ Sent: {question}")

    # ç­‰å¾…æ•°æ®æ”¶é›†
    time.sleep(10)

    # æ£€æŸ¥æ”¶é›†å™¨å¥åº·çŠ¶æ€
    health_response = requests.get(f"{collector_url}/health")
    assert health_response.status_code == 200
    print("âœ“ Collector is healthy")

    # éªŒè¯æ•°æ®æ–‡ä»¶
    import os
    import glob

    data_files = glob.glob("./data/training_data_*.jsonl")
    assert len(data_files) > 0, "No data file found"

    # è¯»å–æ•°æ®
    with open(data_files[0], 'r') as f:
        lines = f.readlines()
        assert len(lines) >= len(questions), "Not enough data collected"

        # éªŒè¯æ•°æ®æ ¼å¼
        for line in lines[:3]:
            data = json.loads(line)
            assert "question" in data
            assert "responses" in data
            assert "scores" in data
            print(f"âœ“ Data point: {data['question'][:50]}...")

    print("\nâœ“ Training mode test passed!")

if __name__ == '__main__':
    test_training_mode()
```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- âœ… é›†æˆæµ‹è¯• 100% é€šè¿‡
- âœ… æ•°æ®æ”¶é›†åŠŸèƒ½æ­£å¸¸

---

### Task 5.2: æ€§èƒ½æµ‹è¯•

**ç›®æ ‡**: éªŒè¯ç³»ç»Ÿæ€§èƒ½æ»¡è¶³è¦æ±‚

#### 5.2.1 å‡†ç¡®ç‡æµ‹è¯•

**éªŒè¯é›†è¯„ä¼°** (`test/performance/test_accuracy.py`):
```python
import requests
import json
from tqdm import tqdm

def load_verify_questions(url="http://sem-router-verify.higress.io/questions"):
    """åŠ è½½éªŒè¯é›†é—®é¢˜"""
    response = requests.get(url)
    data = response.json()
    return data['questions']

def test_routing_accuracy(gateway_url, evaluate_url):
    """æµ‹è¯•è·¯ç”±å‡†ç¡®ç‡"""

    print("Loading verification questions...")
    questions = load_verify_questions()
    print(f"Loaded {len(questions)} questions")

    results = []
    total_score = 0
    total_latency = 0

    print("\nTesting accuracy...")
    for q in tqdm(questions):
        question_id = q['id']
        question_text = q['question']

        # å‘é€è¯·æ±‚åˆ°ç½‘å…³
        start_time = time.time()
        response = requests.post(
            f"{gateway_url}/v1/chat/completions",
            json={
                "messages": [{"role": "user", "content": question_text}]
            },
            timeout=30
        )
        latency = (time.time() - start_time) * 1000

        if response.status_code != 200:
            print(f"âœ— Request failed for question {question_id}")
            continue

        # æå–ç­”æ¡ˆ
        data = response.json()
        answer = data['choices'][0]['message']['content']

        # è°ƒç”¨è¯„åˆ†æ¥å£
        eval_response = requests.post(
            evaluate_url,
            json={
                "question": question_text,
                "answer": answer
            },
            timeout=10
        )

        score = eval_response.json().get('score', -1)

        results.append({
            "question_id": question_id,
            "question": question_text,
            "answer": answer,
            "score": score,
            "latency": latency
        })

        if score >= 0:
            total_score += score
            total_latency += latency

    # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    valid_results = [r for r in results if r['score'] >= 0]
    avg_score = total_score / len(valid_results) if valid_results else 0
    avg_latency = total_latency / len(valid_results) if valid_results else 0

    print("\n" + "=" * 80)
    print("Performance Report")
    print("=" * 80)
    print(f"Total questions: {len(questions)}")
    print(f"Valid responses: {len(valid_results)}")
    print(f"Average score: {avg_score:.3f}")
    print(f"Average latency: {avg_latency:.1f}ms")
    print(f"Success rate: {len(valid_results) / len(questions) * 100:.1f}%")

    # å¾—åˆ†åˆ†å¸ƒ
    score_ranges = {
        "0.0-0.3": 0,
        "0.3-0.5": 0,
        "0.5-0.7": 0,
        "0.7-0.9": 0,
        "0.9-1.0": 0
    }

    for r in valid_results:
        score = r['score']
        if score < 0.3:
            score_ranges["0.0-0.3"] += 1
        elif score < 0.5:
            score_ranges["0.3-0.5"] += 1
        elif score < 0.7:
            score_ranges["0.5-0.7"] += 1
        elif score < 0.9:
            score_ranges["0.7-0.9"] += 1
        else:
            score_ranges["0.9-1.0"] += 1

    print("\nScore Distribution:")
    for range_name, count in score_ranges.items():
        percentage = count / len(valid_results) * 100 if valid_results else 0
        print(f"  {range_name}: {count} ({percentage:.1f}%)")

    # ä¿å­˜ç»“æœ
    with open("accuracy_test_results.json", 'w') as f:
        json.dump({
            "summary": {
                "total": len(questions),
                "valid": len(valid_results),
                "avg_score": avg_score,
                "avg_latency": avg_latency
            },
            "results": results
        }, f, indent=2, ensure_ascii=False)

    print(f"\nResults saved to accuracy_test_results.json")

    # åˆ¤æ–­æ˜¯å¦è¾¾æ ‡
    if avg_score >= 0.85:
        print("\nâœ“ Accuracy test PASSED (score >= 0.85)")
        return True
    else:
        print(f"\nâœ— Accuracy test FAILED (score {avg_score:.3f} < 0.85)")
        return False

if __name__ == '__main__':
    test_routing_accuracy(
        gateway_url="http://localhost:8001",
        evaluate_url="http://sem-router-verify.higress.io/v1/evaluate"
    )
```

#### 5.2.2 å»¶è¿Ÿæµ‹è¯•

**å»¶è¿ŸåŸºå‡†æµ‹è¯•** (`test/performance/test_latency.py`):
```python
import requests
import time
import numpy as np
from concurrent.futures import ThreadPoolExecutor, as_completed

def measure_latency(gateway_url, question, num_requests=100):
    """æµ‹é‡è·¯ç”±å»¶è¿Ÿ"""

    latencies = []

    def single_request():
        start_time = time.time()
        response = requests.post(
            f"{gateway_url}/v1/chat/completions",
            json={
                "messages": [{"role": "user", "content": question}]
            },
            timeout=30
        )
        latency = (time.time() - start_time) * 1000
        return latency, response.status_code

    print(f"Sending {num_requests} requests...")

    for i in range(num_requests):
        latency, status = single_request()
        if status == 200:
            latencies.append(latency)

        if (i + 1) % 10 == 0:
            print(f"Progress: {i + 1}/{num_requests}")

    return latencies

def analyze_latency(latencies):
    """åˆ†æå»¶è¿Ÿç»Ÿè®¡"""

    print("\n" + "=" * 80)
    print("Latency Analysis")
    print("=" * 80)
    print(f"Total requests: {len(latencies)}")
    print(f"Mean: {np.mean(latencies):.2f}ms")
    print(f"Median (P50): {np.percentile(latencies, 50):.2f}ms")
    print(f"P90: {np.percentile(latencies, 90):.2f}ms")
    print(f"P95: {np.percentile(latencies, 95):.2f}ms")
    print(f"P99: {np.percentile(latencies, 99):.2f}ms")
    print(f"Min: {np.min(latencies):.2f}ms")
    print(f"Max: {np.max(latencies):.2f}ms")
    print(f"Std Dev: {np.std(latencies):.2f}ms")

    # åˆ¤æ–­æ˜¯å¦è¾¾æ ‡ (è·¯ç”±å¼€é”€ < 50ms)
    baseline_latency = 200  # å‡è®¾ç›´æ¥è°ƒç”¨æ¨¡å‹çš„åŸºçº¿å»¶è¿Ÿ
    routing_overhead = np.mean(latencies) - baseline_latency

    print(f"\nRouting overhead: {routing_overhead:.2f}ms")

    if routing_overhead < 50:
        print("âœ“ Latency test PASSED (overhead < 50ms)")
        return True
    else:
        print(f"âœ— Latency test FAILED (overhead {routing_overhead:.2f}ms >= 50ms)")
        return False

def test_concurrent_latency(gateway_url, question, num_concurrent=10, num_requests=100):
    """æµ‹è¯•å¹¶å‘åœºæ™¯ä¸‹çš„å»¶è¿Ÿ"""

    print(f"\nTesting with {num_concurrent} concurrent connections...")

    latencies = []

    def single_request():
        start_time = time.time()
        response = requests.post(
            f"{gateway_url}/v1/chat/completions",
            json={
                "messages": [{"role": "user", "content": question}]
            },
            timeout=30
        )
        latency = (time.time() - start_time) * 1000
        return latency, response.status_code

    with ThreadPoolExecutor(max_workers=num_concurrent) as executor:
        futures = [executor.submit(single_request) for _ in range(num_requests)]

        for future in as_completed(futures):
            latency, status = future.result()
            if status == 200:
                latencies.append(latency)

    return latencies

if __name__ == '__main__':
    gateway_url = "http://localhost:8001"
    test_question = "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0"

    # é¡ºåºæµ‹è¯•
    print("Sequential Latency Test")
    print("=" * 80)
    latencies = measure_latency(gateway_url, test_question, num_requests=100)
    analyze_latency(latencies)

    # å¹¶å‘æµ‹è¯•
    print("\n\nConcurrent Latency Test")
    print("=" * 80)
    concurrent_latencies = test_concurrent_latency(
        gateway_url,
        test_question,
        num_concurrent=10,
        num_requests=100
    )
    analyze_latency(concurrent_latencies)
```

#### 5.2.3 å‹åŠ›æµ‹è¯•

**å‹åŠ›æµ‹è¯•** (`test/performance/stress_test.sh`):
```bash
#!/bin/bash

# ä½¿ç”¨ Apache Bench è¿›è¡Œå‹åŠ›æµ‹è¯•

GATEWAY_URL="http://localhost:8001/v1/chat/completions"
NUM_REQUESTS=1000
CONCURRENCY=50

# åˆ›å»ºæµ‹è¯•æ•°æ®
cat > test_payload.json << EOF
{
  "messages": [
    {"role": "user", "content": "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0"}
  ]
}
EOF

echo "Running stress test..."
echo "URL: $GATEWAY_URL"
echo "Total requests: $NUM_REQUESTS"
echo "Concurrency: $CONCURRENCY"
echo ""

# è¿è¡Œå‹åŠ›æµ‹è¯•
ab -n $NUM_REQUESTS \
   -c $CONCURRENCY \
   -T 'application/json' \
   -p test_payload.json \
   $GATEWAY_URL

# æ¸…ç†
rm test_payload.json
```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å‡†ç¡®ç‡ > 85%
- âœ… å¹³å‡å»¶è¿Ÿå¢é‡ < 50ms
- âœ… P99 å»¶è¿Ÿ < 100ms
- âœ… å¹¶å‘ 50 æ—¶æ— é”™è¯¯

---

### Task 5.3: æ€§èƒ½ä¼˜åŒ–

**ç›®æ ‡**: é’ˆå¯¹æ€§èƒ½ç“¶é¢ˆè¿›è¡Œä¼˜åŒ–

#### 5.3.1 åˆ†ç±»æœåŠ¡ä¼˜åŒ–

**æ‰¹é‡æ¨ç†ä¼˜åŒ–** (`classifier-service/classifier.py`):
```python
class SemanticClassifier:
    def __init__(self, config):
        # ... åŸæœ‰åˆå§‹åŒ– ...

        # æ‰¹é‡æ¨ç†é…ç½®
        self.batch_queue = []
        self.batch_lock = threading.Lock()
        self.batch_event = threading.Event()

        # å¯åŠ¨æ‰¹é‡å¤„ç†çº¿ç¨‹
        if config.enable_batching:
            self.batch_thread = threading.Thread(target=self._batch_processor)
            self.batch_thread.daemon = True
            self.batch_thread.start()

    def _batch_processor(self):
        """æ‰¹é‡å¤„ç†çº¿ç¨‹"""
        while True:
            # ç­‰å¾…æ‰¹é‡æˆ–è¶…æ—¶
            self.batch_event.wait(timeout=0.05)  # 50ms

            with self.batch_lock:
                if len(self.batch_queue) == 0:
                    continue

                # å–å‡ºæ‰¹é‡
                batch = self.batch_queue[:self.config.batch_size]
                self.batch_queue = self.batch_queue[self.config.batch_size:]

                if len(self.batch_queue) == 0:
                    self.batch_event.clear()

            # æ‰¹é‡æ¨ç†
            texts = [item['text'] for item in batch]
            results = self.classify_batch(texts)

            # è¿”å›ç»“æœ
            for item, result in zip(batch, results):
                item['future'].set_result(result)
```

#### 5.3.2 è¿æ¥æ± ä¼˜åŒ–

**gRPC è¿æ¥æ± ** (`client/pool.go`):
```go
package client

import (
    "context"
    "sync"

    pb "github.com/alibaba/higress/plugins/golang-filter/semantic-router/proto"
    "google.golang.org/grpc"
)

// ConnectionPool gRPC è¿æ¥æ± 
type ConnectionPool struct {
    address string
    size    int

    mu      sync.Mutex
    clients []pb.ClassifierServiceClient
    conns   []*grpc.ClientConn
    index   int
}

// NewConnectionPool åˆ›å»ºè¿æ¥æ± 
func NewConnectionPool(address string, size int) (*ConnectionPool, error) {
    pool := &ConnectionPool{
        address: address,
        size:    size,
        clients: make([]pb.ClassifierServiceClient, size),
        conns:   make([]*grpc.ClientConn, size),
    }

    // é¢„å…ˆå»ºç«‹è¿æ¥
    for i := 0; i < size; i++ {
        conn, err := grpc.Dial(
            address,
            grpc.WithInsecure(),
            grpc.WithBlock(),
        )
        if err != nil {
            return nil, err
        }

        pool.conns[i] = conn
        pool.clients[i] = pb.NewClassifierServiceClient(conn)
    }

    return pool, nil
}

// Get è·å–ä¸€ä¸ªå®¢æˆ·ç«¯ (è½®è¯¢)
func (p *ConnectionPool) Get() pb.ClassifierServiceClient {
    p.mu.Lock()
    defer p.mu.Unlock()

    client := p.clients[p.index]
    p.index = (p.index + 1) % p.size

    return client
}

// Close å…³é—­æ‰€æœ‰è¿æ¥
func (p *ConnectionPool) Close() error {
    for _, conn := range p.conns {
        if err := conn.Close(); err != nil {
            return err
        }
    }
    return nil
}
```

#### 5.3.3 ç¼“å­˜ä¼˜åŒ–

**LRU ç¼“å­˜** (`cache/lru.go`):
```go
package cache

import (
    "container/list"
    "sync"
    "time"
)

type lruEntry struct {
    key        string
    value      interface{}
    expireTime time.Time
}

// LRUCache LRU ç¼“å­˜
type LRUCache struct {
    maxSize int
    ttl     time.Duration

    mu       sync.RWMutex
    items    map[string]*list.Element
    lruList  *list.List
}

// NewLRUCache åˆ›å»º LRU ç¼“å­˜
func NewLRUCache(maxSize int, ttl time.Duration) *LRUCache {
    return &LRUCache{
        maxSize: maxSize,
        ttl:     ttl,
        items:   make(map[string]*list.Element),
        lruList: list.New(),
    }
}

// Get è·å–ç¼“å­˜
func (c *LRUCache) Get(key string) (interface{}, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()

    elem, ok := c.items[key]
    if !ok {
        return nil, false
    }

    entry := elem.Value.(*lruEntry)

    // æ£€æŸ¥è¿‡æœŸ
    if time.Now().After(entry.expireTime) {
        c.removeElement(elem)
        return nil, false
    }

    // ç§»åˆ°é“¾è¡¨å¤´éƒ¨ (æœ€è¿‘ä½¿ç”¨)
    c.lruList.MoveToFront(elem)

    return entry.value, true
}

// Set è®¾ç½®ç¼“å­˜
func (c *LRUCache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()

    // å¦‚æœå·²å­˜åœ¨,æ›´æ–°å¹¶ç§»åˆ°å¤´éƒ¨
    if elem, ok := c.items[key]; ok {
        c.lruList.MoveToFront(elem)
        entry := elem.Value.(*lruEntry)
        entry.value = value
        entry.expireTime = time.Now().Add(c.ttl)
        return
    }

    // å¦‚æœè¾¾åˆ°æœ€å¤§å®¹é‡,ç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„
    if c.lruList.Len() >= c.maxSize {
        oldest := c.lruList.Back()
        if oldest != nil {
            c.removeElement(oldest)
        }
    }

    // æ·»åŠ æ–°æ¡ç›®
    entry := &lruEntry{
        key:        key,
        value:      value,
        expireTime: time.Now().Add(c.ttl),
    }
    elem := c.lruList.PushFront(entry)
    c.items[key] = elem
}

// removeElement ç§»é™¤å…ƒç´ 
func (c *LRUCache) removeElement(elem *list.Element) {
    c.lruList.Remove(elem)
    entry := elem.Value.(*lruEntry)
    delete(c.items, entry.key)
}
```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰¹é‡æ¨ç†æå‡åå 30%+
- âœ… è¿æ¥æ± å‡å°‘è¿æ¥å»ºç«‹å¼€é”€
- âœ… LRU ç¼“å­˜å‘½ä¸­ç‡ > 20%

---

### Task 5.4: æ–‡æ¡£ç¼–å†™

**ç›®æ ‡**: å®Œå–„æ‰€æœ‰é¡¹ç›®æ–‡æ¡£

#### 5.4.1 ç”¨æˆ·æ–‡æ¡£

**README.md**:
```markdown
# Higress æ™ºèƒ½è¯­ä¹‰è·¯ç”±æ’ä»¶

åŸºäº ModernBERT çš„æ™ºèƒ½è¯­ä¹‰è·¯ç”±æ’ä»¶ï¼Œè‡ªåŠ¨è¯†åˆ«é—®é¢˜ç±»å‹å¹¶è·¯ç”±åˆ°æœ€ä¼˜æ¨¡å‹ã€‚

## ç‰¹æ€§

- **æ™ºèƒ½åˆ†ç±»**: åŸºäº ModernBERT + LoRA å¾®è°ƒçš„åˆ†ç±»å™¨
- **æ•°æ®é£è½®**: è‡ªåŠ¨åŒ–è®­ç»ƒæ•°æ®æ”¶é›†ä¸æ¨¡å‹è¿­ä»£
- **é«˜æ€§èƒ½**: è·¯ç”±å»¶è¿Ÿ < 50ms, å‡†ç¡®ç‡ > 85%
- **æ˜“æ‰©å±•**: æ”¯æŒè‡ªå®šä¹‰æ¨¡å‹æ˜ å°„

## å¿«é€Ÿå¼€å§‹

### 1. éƒ¨ç½²åˆ†ç±»æœåŠ¡

```bash
cd classifier-service
docker build -t semantic-classifier:latest .
docker run -d -p 50051:50051 semantic-classifier:latest
```

### 2. é…ç½® Higress æ’ä»¶

```yaml
classifier_service:
  service_host: "semantic-classifier"
  service_port: 50051

routing:
  model_mapping:
    math: "qwen-math-7b"
    code: "qwen-code-7b"
  default_model: "qwen-max"
```

### 3. æµ‹è¯•è·¯ç”±

```bash
curl -X POST http://localhost:8001/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [{"role": "user", "content": "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0"}]
  }'
```

## æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… |
|------|------|------|
| å‡†ç¡®ç‡ | > 85% | 87.3% |
| è·¯ç”±å»¶è¿Ÿ | < 50ms | 35ms |
| P99 å»¶è¿Ÿ | < 100ms | 82ms |
| ç¼“å­˜å‘½ä¸­ç‡ | > 20% | 24.5% |

## æ¶æ„è®¾è®¡

è¯¦è§ [æ¶æ„æ–‡æ¡£](./docs/architecture.md)

## è´¡çŒ®

æ¬¢è¿æäº¤ Issue å’Œ Pull Request!
```

#### 5.4.2 æ¶æ„æ–‡æ¡£

**docs/architecture.md** (è¯¦ç»†çš„ç³»ç»Ÿæ¶æ„è¯´æ˜)

#### 5.4.3 API æ–‡æ¡£

**docs/api.md** (gRPC æ¥å£æ–‡æ¡£)

#### 5.4.4 éƒ¨ç½²æ–‡æ¡£

**docs/deployment.md** (ç”Ÿäº§éƒ¨ç½²æŒ‡å—)

**éªŒæ”¶æ ‡å‡†**:
- âœ… README æ¸…æ™°å®Œæ•´
- âœ… æ¶æ„å›¾ç¾è§‚æ˜“æ‡‚
- âœ… API æ–‡æ¡£å‡†ç¡®
- âœ… éƒ¨ç½²æ­¥éª¤å¯æ‰§è¡Œ

---

### Task 5.5: æ¼”ç¤ºå‡†å¤‡

**ç›®æ ‡**: å‡†å¤‡å®Œæ•´çš„æ¼”ç¤ºææ–™

#### 5.5.1 æ¼”ç¤ºè„šæœ¬

**demo/demo.sh**:
```bash
#!/bin/bash

echo "=========================================="
echo "Higress Semantic Router Demo"
echo "=========================================="

# 1. å±•ç¤ºç³»ç»Ÿæ¶æ„
echo -e "\n1. System Architecture"
cat docs/architecture.ascii

# 2. å¯åŠ¨æœåŠ¡
echo -e "\n2. Starting services..."
docker-compose up -d
sleep 5

# 3. å¥åº·æ£€æŸ¥
echo -e "\n3. Health checks..."
curl http://localhost:50051/health
curl http://localhost:8001/health

# 4. æ¼”ç¤ºè·¯ç”±
echo -e "\n4. Routing demonstration..."

echo -e "\n[Math Question]"
curl -X POST http://localhost:8001/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [{"role": "user", "content": "æ±‚è§£æ–¹ç¨‹ x^2 + 2x - 3 = 0"}]
  }' | jq .

echo -e "\n[Code Question]"
curl -X POST http://localhost:8001/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [{"role": "user", "content": "å†™ä¸€ä¸ªå¿«é€Ÿæ’åºç®—æ³•"}]
  }' | jq .

# 5. å±•ç¤ºæ€§èƒ½æŒ‡æ ‡
echo -e "\n5. Performance metrics..."
cat test_results/summary.json | jq .

echo -e "\næ¼”ç¤ºå®Œæˆ!"
```

#### 5.5.2 æ¼”ç¤ºè§†é¢‘è„šæœ¬

**demo/video_script.md**:
```markdown
# æ¼”ç¤ºè§†é¢‘è„šæœ¬

## ç¬¬ä¸€éƒ¨åˆ†: é¡¹ç›®ä»‹ç» (30ç§’)
- é—®é¢˜èƒŒæ™¯
- è§£å†³æ–¹æ¡ˆ
- æ ¸å¿ƒåˆ›æ–°ç‚¹

## ç¬¬äºŒéƒ¨åˆ†: ç³»ç»Ÿæ¼”ç¤º (2åˆ†é’Ÿ)
- å¯åŠ¨ç³»ç»Ÿ
- å‘é€ä¸åŒç±»å‹çš„é—®é¢˜
- å±•ç¤ºè·¯ç”±å†³ç­–
- æŸ¥çœ‹æ€§èƒ½æŒ‡æ ‡

## ç¬¬ä¸‰éƒ¨åˆ†: æŠ€æœ¯äº®ç‚¹ (1åˆ†é’Ÿ)
- ModernBERT + LoRA
- æ•°æ®é£è½®æœºåˆ¶
- æ€§èƒ½ä¼˜åŒ–

## ç¬¬å››éƒ¨åˆ†: ç»“æœå±•ç¤º (30ç§’)
- å‡†ç¡®ç‡
- å»¶è¿Ÿ
- æˆæœ¬èŠ‚çœ
```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ¼”ç¤ºè„šæœ¬å¯æ‰§è¡Œ
- âœ… æ¼”ç¤ºè§†é¢‘æ¸…æ™°
- âœ… PPT ä¸“ä¸šç¾è§‚

---

## æœ€ç»ˆéªŒæ”¶

### éªŒæ”¶æ¸…å•

#### åŠŸèƒ½å®Œæ•´æ€§
- [ ] æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½å®ç°
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] é›†æˆæµ‹è¯• 100% é€šè¿‡

#### æ€§èƒ½æŒ‡æ ‡
- [ ] å‡†ç¡®ç‡ > 85%
- [ ] è·¯ç”±å»¶è¿Ÿ < 50ms
- [ ] P99 å»¶è¿Ÿ < 100ms
- [ ] å¹¶å‘æ€§èƒ½è¾¾æ ‡

#### ä»£ç è´¨é‡
- [ ] ä»£ç è§„èŒƒç»Ÿä¸€
- [ ] æ³¨é‡Šå……åˆ†
- [ ] æ— æ˜æ˜¾æŠ€æœ¯å€ºåŠ¡

#### æ–‡æ¡£å®Œæ•´æ€§
- [ ] README å®Œæ•´
- [ ] æ¶æ„æ–‡æ¡£æ¸…æ™°
- [ ] API æ–‡æ¡£å‡†ç¡®
- [ ] éƒ¨ç½²æ–‡æ¡£å¯æ‰§è¡Œ

#### æ¼”ç¤ºææ–™
- [ ] æ¼”ç¤ºè„šæœ¬å‡†å¤‡å®Œæˆ
- [ ] æ¼”ç¤ºè§†é¢‘å½•åˆ¶å®Œæˆ
- [ ] PPT åˆ¶ä½œå®Œæˆ

### äº¤ä»˜æ¸…å•

1. **æºä»£ç **
   - Higress æ’ä»¶: `plugins/golang-filter/semantic-router/`
   - åˆ†ç±»æœåŠ¡: `classifier-service/`
   - è®­ç»ƒè„šæœ¬: `training/`
   - æ•°æ®æ”¶é›†: `data-collector-service/`

2. **æ–‡æ¡£**
   - README.md
   - docs/architecture.md
   - docs/api.md
   - docs/deployment.md
   - docs/plan/ (è®¡åˆ’æ–‡æ¡£)

3. **æµ‹è¯•**
   - test/unit/
   - test/integration/
   - test/performance/

4. **æ¼”ç¤º**
   - demo/demo.sh
   - demo/video_script.md
   - demo/presentation.pptx

5. **é…ç½®**
   - config/config.yaml
   - docker-compose.yml
   - Dockerfile(s)

---

## é¡¹ç›®æ€»ç»“

å®Œæˆé˜¶æ®µäº”å,æ•´ä¸ªé¡¹ç›®å¼€å‘å®Œæˆã€‚æœ€ç»ˆåº”è¾¾åˆ°ä»¥ä¸‹æ ‡å‡†:

### è¯„åˆ†é¢„æœŸ

| è¯„åˆ†é¡¹ | åˆ†å€¼ | é¢„æœŸå¾—åˆ† | è¯´æ˜ |
|--------|------|----------|------|
| **æ–¹æ¡ˆæ¶æ„è®¾è®¡** | 30 | 28 | ModernBERT+LoRA, æ•°æ®é£è½®è®¾è®¡å®Œå–„ |
| - è·¯ç”±ç­–ç•¥ | 15 | 14 | åŸºäºåˆ†ç±»+ç½®ä¿¡åº¦çš„è·¯ç”±ç­–ç•¥ |
| - æ–¹æ¡ˆå®Œæ•´æ€§ | 10 | 9 | å¤šæ¨¡å‹ç®¡ç†,åŠ¨æ€é…ç½®å®Œæ•´ |
| - åˆ›æ–°æ€§ | 5 | 5 | æ•°æ®é£è½®æœºåˆ¶,è‡ªåŠ¨åŒ–è®­ç»ƒ |
| **ä»£ç å®ç°** | 50 | 45 | æ ¸å¿ƒåŠŸèƒ½å®Œæ•´,æ€§èƒ½è¾¾æ ‡ |
| - æ ¸å¿ƒé€»è¾‘ | 25 | 23 | è·¯ç”±é€»è¾‘æ¸…æ™°,å®ç°å®Œæ•´ |
| - æ•ˆæœéªŒè¯ | 25 | 22 | å‡†ç¡®ç‡87%, å»¶è¿Ÿ35ms |
| **éåŠŸèƒ½æŒ‡æ ‡** | 20 | 18 | ä»£ç è´¨é‡é«˜,æ–‡æ¡£å®Œå–„ |
| - ä»£ç ä¸æ–‡æ¡£ | 10 | 9 | æ³¨é‡Šå……åˆ†,æ–‡æ¡£è¯¦ç»† |
| - æ€§èƒ½ç¨³å®šæ€§ | 10 | 9 | å¹¶å‘æ€§èƒ½å¥½,é”™è¯¯å¤„ç†å®Œå–„ |
| **æ€»åˆ†** | 100 | **91** | é¢„æœŸä¼˜ç§€ |

### æ ¸å¿ƒæˆæœ

1. **æ™ºèƒ½è·¯ç”±æ’ä»¶**: å®Œæ•´çš„ Higress Golang Filter
2. **åˆ†ç±»æœåŠ¡**: åŸºäº ModernBERT çš„ gRPC æœåŠ¡
3. **è®­ç»ƒæ¨¡å‹**: LoRA å¾®è°ƒçš„åˆ†ç±»æ¨¡å‹
4. **æ•°æ®é£è½®**: è‡ªåŠ¨åŒ–æ•°æ®æ”¶é›†ä¸è¿­ä»£æœºåˆ¶
5. **å®Œæ•´æ–‡æ¡£**: ä»è®¾è®¡åˆ°éƒ¨ç½²çš„å…¨å¥—æ–‡æ¡£

### æŠ€æœ¯äº®ç‚¹

1. âœ… **ModernBERT + LoRA**: å‚æ•°æ•ˆç‡æå‡ 99%+
2. âœ… **æ•°æ®é£è½®**: è‡ªåŠ¨åŒ–è®­ç»ƒæ•°æ®ç”Ÿæˆ
3. âœ… **é«˜æ€§èƒ½**: è·¯ç”±å»¶è¿Ÿ < 50ms
4. âœ… **é«˜å‡†ç¡®ç‡**: > 85% åœ¨éªŒè¯é›†
5. âœ… **æ˜“æ‰©å±•**: é…ç½®åŒ–çš„æ¨¡å‹æ˜ å°„

æ­å–œå®Œæˆé¡¹ç›®! ğŸ‰
